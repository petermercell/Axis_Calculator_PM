set cut_paste_input [stack 0]
version 15.1 v3
push $cut_paste_input
NoOp {
 name Axis_Calculator_PM7
 selected true
 xpos 1115
 ypos 1321
 hide_input true
 addUserKnob {20 User l Axis_Calculator_PM}
 addUserKnob {26 "" +STARTLINE}
 addUserKnob {3 first l "FIRST FRAME"}
 first 1
 addUserKnob {3 last l "LAST FRAME" -STARTLINE}
 last 240
 addUserKnob {26 ""}
 addUserKnob {1 axis_one l "Child name one (1)"}
 axis_one matrix_data7
 addUserKnob {1 axis_two l "Parent name one (2)"}
 axis_two matrix_data6
 addUserKnob {1 axis_three l "Child name two (3)"}
 axis_three matrix_data_5
 addUserKnob {1 axis_four l "Parent name two (4)"}
 addUserKnob {26 _9 l "Output settings:"}
 addUserKnob {22 ALL_CAL l CALCULATE -STARTLINE T "#http://www.nukepedia.com/written-tutorials/calculation-for-the-transformation-in-world-space\n\nimport nuke\nimport math\n\n# Get the current Nuke node\nref_node = nuke.thisNode()\n\n# Get the input parameters from the node\nchild = ref_node\['axis_one'].getValue()\nparent = ref_node\['axis_two'].getValue()\nchild_two = ref_node\['axis_three'].getValue()\nparent_two = ref_node\['axis_four'].getValue()\nfirst = ref_node\['first'].getValue()\nlast = ref_node\['last'].getValue()\n\n# Initialize matrices\nmAxisParent = nuke.math.Matrix4()\nmAxisChild = nuke.math.Matrix4()\nmAxisParent_two = nuke.math.Matrix4()\nmAxisChild_two = nuke.math.Matrix4()\nmResult = nuke.math.Matrix4()\n\n# Ask the user for the start and end frame range\nstart_frame_input = first\nend_frame_input = last\n\n# Convert user input to integers\ntry:\n    start_frame = int(start_frame_input)\n    end_frame = int(end_frame_input)\nexcept ValueError:\n    # Fallback to root's frame range if input is invalid\n    start_frame = nuke.root().firstFrame()\n    end_frame = nuke.root().lastFrame()\n\n# Dictionary to hold matrix data (replacing CSV file output)\nmatrix_data = \{\}\n\n# Loop over the frame range and calculate matrix results\nfor frame in range(start_frame, end_frame + 1):\n    # Load the first set of matrices (child and parent)\n    for i in range(16):\n        mAxisParent\[i] = nuke.toNode(str(parent))\['matrix'].valueAt(frame)\[i]\n        mAxisChild\[i] = nuke.toNode(str(child))\['matrix'].valueAt(frame)\[i]\n\n    # Step 1: Multiply the first set of matrices (child * parent)\n    mResult = mAxisChild * mAxisParent\n\n    # Step 2: If child_two is defined, multiply by mAxisChild_two\n    if child_two:\n        for i in range(16):\n            mAxisChild_two\[i] = nuke.toNode(str(child_two))\['matrix'].valueAt(frame)\[i]\n        mResult = mResult * mAxisChild_two\n\n    # Step 3: If parent_two is defined, multiply by mAxisParent_two\n    if parent_two:\n        for i in range(16):\n            mAxisParent_two\[i] = nuke.toNode(str(parent_two))\['matrix'].valueAt(frame)\[i]\n        mResult = mResult * mAxisParent_two\n\n    # Store translation result (M03, M13, M23 are the translation components)\n    translation = \[mResult\[3], mResult\[7], mResult\[11]]\n\n    # Transpose the result matrix for rotation calculation\n    mResult.transpose()\n\n    # Store the transposed matrix (used for rotation)\n    matrix_data\[frame] = \{\"translation\": translation, \"matrix\": \[mResult\[i] for i in range(16)]\}\n\n# -------- cal002.py functionality (uses matrix_data instead of reading CSV) -------- #\n\nTranslateList = \[]\nRotateList = \[]\nScaleList = \[]\n\n# Process the matrix data for translation and rotation\nfor frame, data in matrix_data.items():\n    # Extract translation (directly from stored data)\n    translate = data\[\"translation\"]\n    translation_values = \[frame]\n    translation_values.append(translate\[0])  # x translation\n    translation_values.append(translate\[1])  # y translation\n    translation_values.append(translate\[2])  # z translation\n\n    # Extract rotation (convert the transposed matrix to rotation values)\n    matrix = data\[\"matrix\"]\n    mRotate = nuke.math.Matrix4()\n    mRotate.makeIdentity()\n    for i in range(4):\n        for j in range(4):\n            mRotate\[i*4 + j] = matrix\[i*4 + j]\n\n    mRotate.rotationOnly()\n    rotateRad = mRotate.rotationsZXY()\n    rotate = (math.degrees(rotateRad\[0]), math.degrees(rotateRad\[1]), math.degrees(rotateRad\[2]))\n    rotation_values = \[frame]\n    rotation_values.append(rotate\[0])  # x rotation\n    rotation_values.append(rotate\[1])  # y rotation\n    rotation_values.append(rotate\[2])  # z rotation\n\n    # Extract scale values\n    mScale = nuke.math.Matrix4()\n    mScale.makeIdentity()\n    for i in range(4):\n        for j in range(4):\n            mScale\[i*4 + j] = matrix\[i*4 + j]\n\n    mScale.scaleOnly()\n    scale_values = \[frame]\n    scale_values.append(mScale.xAxis().x)  # x scale\n    scale_values.append(mScale.yAxis().y)  # y scale\n    scale_values.append(mScale.zAxis().z)  # z scale\n\n    # Append values to respective lists\n    TranslateList.append(translation_values)\n    RotateList.append(rotation_values)\n    ScaleList.append(scale_values)\n\n# Create a new Axis node in Nuke to apply the translation and rotation\nAxisResult = nuke.createNode(\"Axis\")\nAxisResult.setName(\"Axis_result\")\n\n# Get the Axis translate, rotate, and scale knobs\ntarget_node = AxisResult\ntranslate_knob = target_node\['translate']\nrotate_knob = target_node\['rotate']\nscale_knob = target_node\['scaling']\n\n# Set animated flags for the knobs\ntranslate_knob.setAnimated()\nrotate_knob.setAnimated()\nscale_knob.setAnimated()\n\n# Set keyframes for translation\nfor sublist in TranslateList:\n    frame = int(sublist\[0])  # Assuming the frame is in the first column\n    x_translation = float(sublist\[1])\n    y_translation = float(sublist\[2])\n    z_translation = float(sublist\[3])\n\n    translate_knob.setValue(x_translation, 0, frame)  # Set x translation \n    translate_knob.setValue(y_translation, 1, frame)  # Set y translation\n    translate_knob.setValue(z_translation, 2, frame)  # Set z translation\n\n# Set keyframes for rotation\nfor sublist in RotateList:\n    frame = int(sublist\[0])  # Assuming the frame is in the first column\n    x_rotate = float(sublist\[1])\n    y_rotate = float(sublist\[2])\n    z_rotate = float(sublist\[3])\n\n    rotate_knob.setValue(x_rotate, 0, frame)  # Set x rotation \n    rotate_knob.setValue(y_rotate, 1, frame)  # Set y rotation\n    rotate_knob.setValue(z_rotate, 2, frame)  # Set z rotation\n\n# Set keyframes for scale\nfor sublist in ScaleList:\n    frame = int(sublist\[0])  # Assuming the frame is in the first column\n    x_scale = float(sublist\[1])\n    y_scale = float(sublist\[2])\n    z_scale = float(sublist\[3])\n\n    scale_knob.setValue(x_scale, 0, frame)  # Set x scale\n    scale_knob.setValue(y_scale, 1, frame)  # Set y scale\n    scale_knob.setValue(z_scale, 2, frame)  # Set z scale"}
 addUserKnob {26 ""}
 addUserKnob {26 _1 l "" +STARTLINE T "Axis_Calculator v0.91 by Peter Mercell 2024"}
 addUserKnob {26 _2 l "" +STARTLINE T "<a style=\"color: #999999;\"><a style=\"color: #999999;\" href=\"http://www.petermercell.com\" target=\"_blank\" rel=\"noopener\">www.petermercell.com</a>"}
 addUserKnob {26 _3 l "" -STARTLINE T "<a style=\"color: #999999;\"><a style=\"color: #999999;\" href=\"http://www.nukepedia.com/written-tutorials/calculation-for-the-transformation-in-world-space\" target=\"_blank\" rel=\"noopener\">Source thank you Masahiro Teraoka</a>"}
}
